<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script> <script type="text/x-mathjax-config"> MathJax.Hub.Config({ tex2jax: { skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'], inlineMath: [['$','$'], ["\\(","\\)"],["\(", "\)"]], displayMath: [["$$","$$"], ["\\[","\\]"],["\[", "\]"]] } }); </script>

# 20240xl4ughctf密码学部分题目复现

## ECDSA与Grobner基：利用sage解约束方程(Capawchino Cafe)

本题来自于2024年0xl4ughctf的一道密码学题，里面的数学原理Grobner基其实不是很会，但是希望以后遇到相似的题目至少有思路，会调用sage脚本。解题主要分为三个部分：
1. AES.CRT，这一部分因为复用了`IV`，导致每次异或时使用的`KEY`相同，因此根据题目给的一个例子异或出`KEY`，然后每次用相同的`KEY`加密得到密文即可。
2. 上面每成功配对一组，就可以得到一组基于椭圆曲线的签名，一共有8组签名`(r,s)`，每次签名使用了不同的随机数，这些随机数`ki`之间存在一定关系，我们的目标是还原私钥`d`。
3. 题目还会给出一组密文，前十六字节为`iv`，后面的字节为AES.CBC模式加密后的内容，`key`为私钥`d`的sha256值，因此本题重点就在于还原`d`。

首先考察`ECDSA`的签名过程：$r=(k*G)_x,s=k^{-1}(H(m)+rd)$。以上均要考虑`mod n`,`n`为`G`的阶，事实上也是该椭圆曲线的阶(对于`NIST224p`是这样的，别的不一定)。`H(m)`是消息的哈希函数值，对于本题而言是固定且已知的。以及题目给出了这些随机数`k`之间的关系：
```python
    def gen_ks(self):
        c = [random.randint(1, self.curve.order - 1) for _ in range(6)]
        self.ks = [random.randint(1, self.curve.order - 1)]
        for i in range(7):
            k = int(sum((c[j] * (self.ks[i] ** j)) %
                    self.curve.order for j in range(6)) % self.curve.order)
            self.ks.append(k)
```
定义了一个长度为6的未知数组`c`，随机生成了`k0`，之后根据数组`c`生成后续的7个`k`，因此一共有6个未知的`ci`，8个未知的`ki`，以及一个未知的`d`，相当于有15个未知数。那有多少个约束方程呢，签名给出了8个方程($s_i=k_i^{-1}(H(m)+r_id)$)，需要注意的是这里的`ki`是从数组`k`中pop出去的，在队尾，因此第一组签名的随机数`k`实际上是最后一个，需要注意顺序。以及8个`ki`之间的生成关系给出了7个约束，一共15个约束方程。因此相当于是知道15个方程，求15个未知数。

现在就可以来使用sage了，本地测试代码如下：
```python
n=26959946667150639794667015087019625940457807714424391721682722368061
K=GF(n)
signature=[{"s": 17460247877294934395053531904905099232378834614720488560789942655193, "r": 5989736301624879313806684623716438026890850498654681682335756459139},    
{"s": 21210877680299334152445033205630180178365341746173075474529128947838, "r": 10065041569245340018327055661912946729254338302865694936578612234353} ,  
{"s": 20182988305345754605319340236407033253700696514015505641734269797091, "r": 19372401586000543966999802557627184369957697177935060594305218003360} ,  
{"s": 9718935180305478008029982391317006129215504107273075524308265740749, "r": 11351747053276328661349652764079936871566752375677034036287054569819}  ,  
{"s": 5768126868806809805115835084873195490121213931371989436772242054293, "r": 9917106834430922813996577466412975433961951417923342313509770139050} ,    
{"s": 9854119456833294601816910447287717358926748037430938891482068346781, "r": 5993519848129462803742839130765898209259430303634391816594696362891} ,    
{"s": 9582715911911137575522570820254847979439811274309504748922058101864, "r": 14666170909998624930862183751239673274718390708205485453712101918785} ,   
{"s": 25040533659124655792296248925554208304810514374267006649887700818996, "r": 19176644730912321562992950123191562711610015559673809978854570592852}]
si = [K(sign["s"]) for sign in signature][::-1]
ri = [K(sign["r"]) for sign in signature][::-1]
m=17652096005390789500184919532088101572530464893898551787768088100952
h = K(m)

P = PolynomialRing(K, ["c" + str(i) for i in range(6)] +["k" + str(i) for i in range(8)] + ["d"], order="lex")
un = P.gens()      

ci = un[0:6]
ki = un[6:-1]
d = un[-1]

eqs = []

eqs += [si[i] * ki[i] - h - ri[i] * d for i in range(8)]      
for i in range(7):
    eqs+=[ki[i+1]-sum(ci[j]*ki[i]**j for j in range(6))]       # 添加约束
 
I = P.ideal(eqs)
Ir = P.ideal(I.groebner_basis())

S = Ir.variety() 

print(S[0])   # 给出所有未知数
```
这里事实上就用到了Grobner基解决了约束问题，先定义了一个`GF(n)`上的多项式环，并添加了十五个未知量(相当于x,y,z...)，然后给出了一组生成元，再往里面添加约束并求得环的理想，然后就解出约束了(这是大致过程，具体原理还得细细推敲)。

## Private Curve

非常感谢[Connor](https://connor-mccartney.github.io/cryptography/ecc/PrivateCurve-0xl4ughCTF2024)提供的参考wp，本题源代码如下：
```py
from Crypto.Util.number import getPrime,bytes_to_long
from secret import flag, p,a,b

flag=bytes_to_long(flag)

E = EllipticCurve(GF(p), [a, b])
G = E.gens()[0]


P=G*flag
print('here is my 7 xs can u get my private key ?')
#print(P[0])
for i in range(7):
	PP=P+i*G
	print(PP[0])

'''
here is my 7 xs can u get my private key ?
127222731808447286384197097524849730324280912084690383123034174156693907296321941583008138816149304043198829099586978152639
540150767459876746741544981524050320567261340627105743010550795668800394677819357272612801849680099119164471834128771848184
378426912752589864658307848293724051252472266429208255456184007500868515338668653822829851730193370970777687937350186024739
114528622155057967694026934367142168000739167063266001591280862125480038107282641048998814104241182719055831758176542012114
322400405850331256663554456242498354334347017862265389196757152850674454034744292814021471167045908645361119988919752367867
496047308313146975448000924265615728665813401349451895964344399497579232646901690982051726266819379622021083585061713111901
339613985780778130822549050414603776860269549419836797423421156347303558845214120048926926114443864057942273222884788713615
'''
```
非常简洁，仅仅给出了7个椭圆曲线上的点的$x$坐标，分别是$P,P+G...P+6G$，而$P=G*flag$，此外没有给出任何信息，甚至没有给出椭圆曲线的参数$p,a,b$，我也不知道博主从哪里找到了一篇[paper](https://arxiv.org/pdf/1609.03305)就记载了如何通过这样的序列还原椭圆曲线的参数。

这里就不直接给出具体数学原理了，直接给出论文的攻击手段。首先记这7个$x$的坐标依次为$x_1,x_2,...x_7$，并且构造矩阵C如下：
\[
C = 
\begin{bmatrix}
2x_2^2 + 2x_2(x_1 + x_3) & 2x_2 - (x_1 + x_3) & 2x_2 & 2 \\
2x_3^2 + 2x_3(x_2 + x_4) & 2x_3 - (x_2 + x_4) & 2x_3 & 2 \\
2x_4^2 + 2x_4(x_3 + x_5) & 2x_4 - (x_3 + x_5) & 2x_4 & 2 \\
2x_5^2 + 2x_5(x_4 + x_6) & 2x_5 - (x_4 + x_6) & 2x_5 & 2 \\
2x_6^2 + 2x_6(x_5 + x_7) & 2x_6 - (x_5 + x_7) & 2x_6 & 2
\end{bmatrix}
\]
再构造矢量u:
\[
u = 
\begin{bmatrix}
(x_1 + x_3) \cdot x_2^2 \\
(x_2 + x_4) \cdot x_3^2 \\
(x_3 + x_5) \cdot x_4^2 \\
(x_4 + x_6) \cdot x_5^2 \\
(x_5 + x_7) \cdot x_6^2
\end{bmatrix}
\]
现在记$m=det(C,u)$，然后尝试去解方程$Ce=umod m$，这里可以保证$p|m$，这里我们必须常识逐渐去消除掉$m$多余的因子，并保留素数$p$，比方说除去100以内的因子可以采用博主[Connor](https://connor-mccartney.github.io/cryptography/ecc/PrivateCurve-0xl4ughCTF2024)给出的如下代码：
```python
m = C.augment(u).det()

for _ in range(100):
    C = C.change_ring(Zmod(m))
    for uu in range(1, 100):
        try:
            l1, l2, l3, l4 = C.solve_right(uu*u).T[0]
            break
        except:
            pass
    m //= gcd(m, uu)
```
看看GPT的解释：

**1. 初始设置**
- 通过 `C.augment(u).det()` 计算 \( m = \det(C_1, C_2, C_3, C_4, u) \)。  
  这一步利用了 \( u \) 与 \( C_1, C_2, C_3, C_4 \) 的线性依赖性质，确保在模 \( m \) 下方程有解。
  
**2. 矩阵元素转入有限域**
- 使用 `C = C.change_ring(Zmod(m))` 将矩阵 \( C \) 转换为模 \( m \) 的有限域下进行运算。这种变换使得接下来的计算都在模 \( m \) 的环境中进行。

**3. 寻找线性依赖关系**
- 遍历 \( uu \)（从 1 到 99），尝试解决线性方程 \( C \cdot x \equiv uu \cdot u \mod m \)。这实际上是在检查 \( uu \cdot u \) 是否在线性空间 \( \text{span}(C_1, C_2, C_3, C_4) \) 内。
- 如果有解，意味着当前模数 \( m \) 未必能保证 \( C_1, C_2, C_3, C_4 \) 的完全独立性。

**4. 减小模数 \( m \)**
- 每次找到解后，通过 `m //= gcd(m, uu)` 将模数 \( m \) 进一步缩小。
- 减小模数的核心是剔除多余的因子，同时保留模 \( p \)（目标素数）作为因子。这会逐步消除潜在的线性依赖性。

**5. 迭代收敛**
- 上述过程会重复进行最多 100 次，确保每一次都缩小模数 \( m \)。
- 通过迭代，可以得到一个尽可能小的模数 \( m \)，同时保证 \( C_1, C_2, C_3, C_4 \) 在该模数下线性独立。


经过测试可以发现，外面第二层循环时$m$就不再变化了。现在用新的$m$求解方程，如果不满足($e_1^2=e_2modm$)，继续更新$m=gcd(m,e_1^2-e_2)$，然后有：$p=max(factor(m)),A=\lambda_3,B=(\lambda_4-\lambda_1\lambda_3)/2$，以上均在modm意义上。现在可以确定椭圆曲线了，然后通过寻找椭圆曲线上给定的P点坐标寻找到相应的P，满足$P_3-P_2=P_2-P_1=G$。
最后观察到该点的阶很光滑，利用P-H算法求解离散对数问题即可得到flag。在这里附上完整脚本，博主github博客首页为https://connor-mccartney.github.io，再次感谢，以后做到类似的题可以直接照搬脚本了：
```python
from Crypto.Util.number import *

x1 = 127222731808447286384197097524849730324280912084690383123034174156693907296321941583008138816149304043198829099586978152639
x2 = 540150767459876746741544981524050320567261340627105743010550795668800394677819357272612801849680099119164471834128771848184
x3 = 378426912752589864658307848293724051252472266429208255456184007500868515338668653822829851730193370970777687937350186024739
x4 = 114528622155057967694026934367142168000739167063266001591280862125480038107282641048998814104241182719055831758176542012114
x5 = 322400405850331256663554456242498354334347017862265389196757152850674454034744292814021471167045908645361119988919752367867
x6 = 496047308313146975448000924265615728665813401349451895964344399497579232646901690982051726266819379622021083585061713111901
x7 = 339613985780778130822549050414603776860269549419836797423421156347303558845214120048926926114443864057942273222884788713615

C = Matrix([
    [2*x2**2 + 2*x2*(x1+x3), 2*x2 - (x1+x3), 2*x2, 2],
    [2*x3**2 + 2*x3*(x2+x4), 2*x3 - (x2+x4), 2*x3, 2],
    [2*x4**2 + 2*x4*(x3+x5), 2*x4 - (x3+x5), 2*x4, 2],
    [2*x5**2 + 2*x5*(x4+x6), 2*x5 - (x4+x6), 2*x5, 2],
    [2*x6**2 + 2*x6*(x5+x7), 2*x6 - (x5+x7), 2*x6, 2],
])

u = Matrix([
    [(x1+x3) * x2**2],
    [(x2+x4) * x3**2],
    [(x3+x5) * x4**2],
    [(x4+x6) * x5**2],
    [(x5+x7) * x6**2],
])

m = C.augment(u).det()

for _ in range(100):
    C = C.change_ring(Zmod(m))
    for uu in range(1, 100):
        try:
            l1, l2, l3, l4 = C.solve_right(uu*u).T[0]
            break
        except:
            pass
    m //= gcd(m, uu)

l1, l2, l3, l4 = C.solve_right(u).T[0]
m = gcd(m, l1**2-l2)
p = max(factor(int(m)))[0]
A = l3 % p
B = (l4 - l1*l3) * pow(2, -1, p) % p
E = EllipticCurve(GF(p), [A, B])

possible_G = []
for P1 in E.lift_x(ZZ(x1), all=True):
    for P2 in E.lift_x(ZZ(x2), all=True):
        for P3 in E.lift_x(ZZ(x3), all=True):
            G1 = P2 - P1
            G2 = P3 - P2
            if G1 == G2:
                possible_G.append(G1)

# G.order()
order = 556965490678630938378478504080786693800314491282937950160435260930503737423792557485852859174204084888400324899682328099393
#print(factor(order))
primes = [72227181939217 , 108661850383939 , 109941210688553 , 117077820297817 , 118416071094367 , 139218006249863]


for G in possible_G:
    for P in E.lift_x(ZZ(x1), all=True):
        dlogs = []
        """
        for fac in primes:
            t = int(order) // int(fac)
            dlog = (t*P).log(t*G)
            dlogs += [dlog]
            print(dlogs)
        """
        dlogs = [51088168138150, 20841038223433, 99422819666350, 84141054836054, 92245366899078, 44522182731635]
        flag = crt(dlogs, primes)
        print(long_to_bytes(int(flag)))
```
PS: ecc常见攻击手段
1. 直接分解；
2. 如果生成点的阶比较光滑(分解质因数数目与大小合适)，可采用P-H算法；
3. 如果椭圆曲线的阶与模数p相同，可以采用Smart攻击；
4. 如果椭圆曲线的阶是$p^k-1$的因数，这里的$k$较小，可以考虑采用mov攻击。