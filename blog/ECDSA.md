# ECDSA与Grobner基：利用sage解约束方程

本题来自于2024年0xl4ughctf的一道密码学题，里面的数学原理`Grobner基`其实不是很会，但是希望以后遇到相似的题目至少有思路，会调用sage脚本。解题主要分为三个部分：
1. AES.CRT，这一部分因为复用了`IV`，导致每次异或时使用的`KEY`相同，因此根据题目给的一个例子异或出`KEY`，然后每次用相同的`KEY`加密得到密文即可。
2. 上面每成功配对一组，就可以得到一组基于椭圆曲线的签名，一共有8组签名`(r,s)`，每次签名使用了不同的随机数，这些随机数`ki`之间存在一定关系，我们的目标是还原私钥`d`。
3. 题目还会给出一组密文，前十六字节为`iv`，后面的字节为AES.CBC模式加密后的内容，`key`为私钥`d`的sha256值，因此本题重点就在于还原`d`。

首先考察`ECDSA`的签名过程：$r=(k*G)_x,s=k^{-1}(H(m)+rd)$。以上均要考虑`mod n`,`n`为`G`的阶，事实上也是该椭圆曲线的阶(对于`NIST224p`是这样的，别的不一定)。`H(m)`是消息的哈希函数值，对于本题而言是固定且已知的。以及题目给出了这些随机数`k`之间的关系：
```python
    def gen_ks(self):
        c = [random.randint(1, self.curve.order - 1) for _ in range(6)]
        self.ks = [random.randint(1, self.curve.order - 1)]
        for i in range(7):
            k = int(sum((c[j] * (self.ks[i] ** j)) %
                    self.curve.order for j in range(6)) % self.curve.order)
            self.ks.append(k)
```
定义了一个长度为6的未知数组`c`，随机生成了`k0`，之后根据数组`c`生成后续的7个`k`，因此一共有6个未知的`ci`，8个未知的`ki`，以及一个未知的`d`，相当于有15个未知数。那有多少个约束方程呢，签名给出了8个方程($s_i=k_i^{-1}(H(m)+r_id)$)，需要注意的是这里的`ki`是从数组`k`中pop出去的，在队尾，因此第一组签名的随机数`k`实际上是最后一个，需要注意顺序。以及8个`ki`之间的生成关系给出了7个约束，一共15个约束方程。因此相当于是知道15个方程，求15个未知数。

现在就可以来使用sage了，本地测试代码如下：
```python
n=26959946667150639794667015087019625940457807714424391721682722368061
K=GF(n)
signature=[{"s": 17460247877294934395053531904905099232378834614720488560789942655193, "r": 5989736301624879313806684623716438026890850498654681682335756459139},    
{"s": 21210877680299334152445033205630180178365341746173075474529128947838, "r": 10065041569245340018327055661912946729254338302865694936578612234353} ,  
{"s": 20182988305345754605319340236407033253700696514015505641734269797091, "r": 19372401586000543966999802557627184369957697177935060594305218003360} ,  
{"s": 9718935180305478008029982391317006129215504107273075524308265740749, "r": 11351747053276328661349652764079936871566752375677034036287054569819}  ,  
{"s": 5768126868806809805115835084873195490121213931371989436772242054293, "r": 9917106834430922813996577466412975433961951417923342313509770139050} ,    
{"s": 9854119456833294601816910447287717358926748037430938891482068346781, "r": 5993519848129462803742839130765898209259430303634391816594696362891} ,    
{"s": 9582715911911137575522570820254847979439811274309504748922058101864, "r": 14666170909998624930862183751239673274718390708205485453712101918785} ,   
{"s": 25040533659124655792296248925554208304810514374267006649887700818996, "r": 19176644730912321562992950123191562711610015559673809978854570592852}]
si = [K(sign["s"]) for sign in signature][::-1]
ri = [K(sign["r"]) for sign in signature][::-1]
m=17652096005390789500184919532088101572530464893898551787768088100952
h = K(m)

P = PolynomialRing(K, ["c" + str(i) for i in range(6)] +["k" + str(i) for i in range(8)] + ["d"], order="lex")
un = P.gens()      

ci = un[0:6]
ki = un[6:-1]
d = un[-1]

eqs = []

eqs += [si[i] * ki[i] - h - ri[i] * d for i in range(8)]      
for i in range(7):
    eqs+=[ki[i+1]-sum(ci[j]*ki[i]**j for j in range(6))]       # 添加约束
 
I = P.ideal(eqs)
Ir = P.ideal(I.groebner_basis())

S = Ir.variety() 

print(S[0])   # 给出所有未知数
```
这里事实上就用到了Grobner基解决了约束问题，先定义了一个`GF(n)`上的多项式环，并添加了十五个未知量(相当于x,y,z...)，然后给出了一组生成元，再往里面添加约束并求得环的理想，然后就解出约束了(这是大致过程，具体原理还得细细推敲)。